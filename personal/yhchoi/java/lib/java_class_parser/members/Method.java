/**
 * 
 *  Method.java - A class that holds a method in a .class file.
 *  Copyright (C) 2024 YH Choi
 *
 *  This program is licensed under BSD 3-Clause License.
 *  See LICENSE.txt for details.
 * 
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package personal.yhchoi.java.lib.java_class_parser.members;

import java.io.DataInputStream;
import java.io.IOException;
import java.util.List;
import personal.yhchoi.java.lib.java_class_parser.ConstPoolRetriever;
import personal.yhchoi.java.lib.java_class_parser.attributes.Attribute;

/**
 * A method in a .class file.
 *
 * @author Yui Hei Choi
 * @version 2025.01.15
 */
public class Method extends Member
{
    /** Declared <code>synchronized</code>; invocation is wrapped by a monitor use. */
    private static final int ACC_SYNCHRONIZED   = 0x0020;
    
    /** A bridge method, generated by the compiler. */
    private static final int ACC_BRIDGE         = 0x0040;
    
    /** Declared with variable number of arguments. */
    private static final int ACC_VARARGS        = 0x0080;
    
    /** Declared <code>native</code>; implemented in a language other than Java. */
    private static final int ACC_NATIVE         = 0x0100;
    
    /** Declared <code>abstract</code>; no implementation is provided. */
    private static final int ACC_ABSTRACT       = 0x0400;
    
    /** Declared <code>strictfp</code>; floating-point mode is FP-strict. */
    private static final int ACC_STRICT         = 0x0800;
    
    /**
     * Constructor for objects of class Method.
     * 
     * @param consts the constant pool retriever
     * @param accessFlags the access flags of this method
     * @param nameIndex the index of name of this method
     * @param descriptorIndex the index of descriptor of this method
     * @param attributes attributes of this method
     */
    protected Method(ConstPoolRetriever consts, int accessFlags, int nameIndex, int descriptorIndex, Attribute[] attributes)
    {
        super(consts, accessFlags, nameIndex, descriptorIndex, attributes);
    }
    
    /**
     * Creates a method from the input stream.
     * 
     * @param inStream the input stream to read the .class file
     * @param consts the constant pool retriever
     * @return the newly created method, or null if operation failed
     * @throws IOException if the input stream fails to read the entire method
     */
    public static final Method createMethod(DataInputStream inStream, ConstPoolRetriever consts) throws IOException
    {
        return (Method)createMember(inStream, consts, true);
    }
    
    /**
     * Gets the method parameters from the method descriptor.
     * 
     * @return the parameters of the method
     */
    public final String getParameters()
    {
        final String descriptor = getDescriptor();
        final String parametersDescriptor = descriptor.substring(descriptor.indexOf("(") + 1, descriptor.indexOf(")"));
        List<String> params = getTypesFromDescriptor(parametersDescriptor);
        String toReturn = "";
        final int paramsCount = params.size();
        final boolean varargs = isVarargs();
        for (int i = 0; i < paramsCount - 1; i++) {
            final String param = params.get(i);
            toReturn += param + " x" + i + ", ";
        }
        if (paramsCount >= 1) {
            String param = params.get(paramsCount - 1);
            if (varargs) {
                param = param.substring(0, param.length() - 2) + "...";
            }
            toReturn += param + " x" + (paramsCount - 1);
        }
        // for (int i = 0; i < paramsCount; i++) {
        //     final boolean lastParam = (i == (paramsCount - 1));
        //     String param = params.get(i);
        //     if (varargs && lastParam) {
        //         param = param.substring(0, param.length() - 2) + "...";
        //     }
        //     toReturn += param + " x" + i;
        //     if (!lastParam) {
        //         toReturn += ", ";
        //     }
        // }
        return toReturn;
    }
    
    /**
     * Gets the return type from the method descriptor.
     * 
     * @return the return type of the method
     */
    public final String getReturnType()
    {
        final String descriptor = getDescriptor();
        final String returnTypeDescriptor = descriptor.substring(descriptor.indexOf(")") + 1);
        if ("V".equals(returnTypeDescriptor)) {
            return "void";
        }
        return getTypeFromDescriptor(returnTypeDescriptor);
    }
    
    /**
     * Checks if this method is <code>synchronized</code>.
     * If this is the case, then its invocation is wrapped by a monitor use.
     * 
     * @return true if declared <code>synchronized</code>; invocation is wrapped by a monitor use
     */
    public final boolean isSynchronized()
    {
        return checkAccessFlag(ACC_SYNCHRONIZED);
    }
    
    /**
     * Checks if this method is a bridge.
     * If this is the case, then it is generated by the compiler.
     * 
     * @return true if is bridge method, generated by the compiler
     */
    public final boolean isBridge()
    {
        return checkAccessFlag(ACC_BRIDGE);
    }
    
    /**
     * Checks if this method has a variable number of arguments.
     * 
     * @return true if declared with variable number of arguments
     */
    public final boolean isVarargs()
    {
        return checkAccessFlag(ACC_VARARGS);
    }
    
    /**
     * Checks if this method is native code.
     * If this is the case, then it is implemented in a language other than Java.
     * 
     * @return true if declared <code>native</code>; implemented in a language other than Java
     */
    public final boolean isNative()
    {
        return checkAccessFlag(ACC_NATIVE);
    }
    
    /**
     * Checks if this method is <code>abstract</code>.
     * If this is the case, then it is not implemented.
     * 
     * @return true if declared <code>abstract</code>; no implementation is provided
     */
    public final boolean isAbstract()
    {
        return checkAccessFlag(ACC_ABSTRACT);
    }
    
    /**
     * Checks if this method is <code>strictfp</code>.
     * If this is the case, then its floating-point mode is FP-strict.
     * 
     * @return true if declared <code>strictfp</code>; floating-point mode is FP-strict
     */
    public final boolean isStrict()
    {
        return checkAccessFlag(ACC_STRICT);
    }
}
